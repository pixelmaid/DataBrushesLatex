\documentclass{sigchi}

% Use this section to set the ACM copyright statement (e.g. for
% preprints).  Consult the conference website for the camera-ready
% copyright statement.

% Copyright
\CopyrightYear{2016}
%\setcopyright{acmcopyright}
\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}
% DOI
\doi{http://dx.doi.org/10.475/123_4}
% ISBN
\isbn{123-4567-24-567/08/06}
%Conference
\conferenceinfo{CHI'16,}{May 07--12, 2016, San Jose, CA, USA}
%Price
\acmPrice{\$15.00}

% Use this command to override the default ACM copyright statement
% (e.g. for preprints).  Consult the conference website for the
% camera-ready copyright statement.

%% HOW TO OVERRIDE THE DEFAULT COPYRIGHT STRIP --
%% Please note you need to make sure the copy for your specific
%% license is used here!
% \toappear{
% Permission to make digital or hard copies of all or part of this work
% for personal or classroom use is granted without fee provided that
% copies are not made or distributed for profit or commercial advantage
% and that copies bear this notice and the full citation on the first
% page. Copyrights for components of this work owned by others than ACM
% must be honored. Abstracting with credit is permitted. To copy
% otherwise, or republish, to post on servers or to redistribute to
% lists, requires prior specific permission and/or a fee. Request
% permissions from \href{mailto:Permissions@acm.org}{Permissions@acm.org}. \\
% \emph{CHI '16},  May 07--12, 2016, San Jose, CA, USA \\
% ACM xxx-x-xxxx-xxxx-x/xx/xx\ldots \$15.00 \\
% DOI: \url{http://dx.doi.org/xx.xxxx/xxxxxxx.xxxxxxx}
% }

% Arabic page numbers for submission.  Remove this line to eliminate
% page numbers for the camera ready copy
% \pagenumbering{arabic}

% Load basic packages
\usepackage{balance}       % to better equalize the last page
\usepackage{graphics}      % for EPS, load graphicx instead 
\usepackage[T1]{fontenc}   % for umlauts and other diaeresis
\usepackage{txfonts}
\usepackage{mathptmx}
\usepackage[pdflang={en-US},pdftex]{hyperref}
\usepackage{color}
\usepackage{booktabs}
\usepackage{textcomp}

%% for comments
\newcommand {\jen}[1]{{\color{teal}\bf{JJ: #1}\normalfont}}
\newcommand {\maneesh}[1]{{\color{blue}\bf{MA: #1}\normalfont}}
\newcommand {\jingyi}[1]{{\color{purple}\bf{JL: #1}\normalfont}}
\newcommand {\joel}[1]{{\color{olive}{JB: #1}\normalfont}}
\newcommand {\radomir}[1]{{\color{green}{RM: #1}\normalfont}}


% Some optional stuff you might like/need.
\usepackage{microtype}        % Improved Tracking and Kerning
% \usepackage[all]{hypcap}    % Fixes bug in hyperref caption linking
\usepackage{ccicons}          % Cite your images correctly!
% \usepackage[utf8]{inputenc} % for a UTF8 editor only

% If you want to use todo notes, marginpars etc. during creation of
% your draft document, you have to enable the "chi_draft" option for
% the document class. To do this, change the very first line to:
% "\documentclass[chi_draft]{sigchi}". You can then place todo notes
% by using the "\todo{...}"  command. Make sure to disable the draft
% option again before submitting your final document.
\usepackage{todonotes}

% Paper metadata (use plain text, for PDF inclusion and later
% re-using, if desired).  Use \emtpyauthor when submitting for review
% so you remain anonymous.
%\def\plaintitle{Hybrid Representations: A Model for Integrating Autonomous and Manual Production}
\def\plaintitle{Data-driven Generative Art}
\def\plainauthor{First Author, Second Author, Third Author,
  Fourth Author, Fifth Author, Sixth Author}
\def\emptyauthor{}
\def\plainkeywords{Generative art; programming; data visualization}

\def\plaingeneralterms{Documentation, Standardization}

% llt: Define a global style for URLs, rather that the default one
\makeatletter
\def\url@leostyle{%
  \@ifundefined{selectfont}{
    \def\UrlFont{\sf}
  }{
    \def\UrlFont{\small\bf\ttfamily}
  }}
\makeatother
\urlstyle{leo}

% To make various LaTeX processors do the right thing with page size.
\def\pprw{8.5in}
\def\pprh{11in}
\special{papersize=\pprw,\pprh}
\setlength{\paperwidth}{\pprw}
\setlength{\paperheight}{\pprh}
\setlength{\pdfpagewidth}{\pprw}
\setlength{\pdfpageheight}{\pprh}

% Make sure hyperref comes last of your loaded packages, to give it a
% fighting chance of not being over-written, since its job is to
% redefine many LaTeX commands.
\definecolor{linkColor}{RGB}{6,125,233}
\hypersetup{%
  pdftitle={\plaintitle},
% Use \plainauthor for final version.
%  pdfauthor={\plainauthor},
  pdfauthor={\emptyauthor},
  pdfkeywords={\plainkeywords},
  pdfdisplaydoctitle=true, % For Accessibility
  bookmarksnumbered,
  pdfstartview={FitH},
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=linkColor,
  breaklinks=true,
  hypertexnames=false
}

% create a shortcut to typeset table headings
% \newcommand\tabhead[1]{\small\textbf{#1}}

% End of preamble. Here it comes the document.
\begin{document}

\title{\plaintitle}

\numberofauthors{3}
\author{%
 % \alignauthor{Leave Authors Anonymous\\
  %  \affaddr{for Submission}\\
 %   \affaddr{City, Country}\\
 %   \email{e-mail address}}\\
 % \alignauthor{Leave Authors Anonymous\\
%    \affaddr{for Submission}\\
 %   \affaddr{City, Country}\\
 %   \email{e-mail address}}\\
 % \alignauthor{Leave Authors Anonymous\\
%    \affaddr{for Submission}\\
%    \affaddr{City, Country}\\
%    \email{e-mail address}}\\
}

\maketitle

\begin{abstract}
 %Integrating data and traditional forms of artistic creation, like drawing, enables the the production of data-driven art with hand-made qualities and offers a powerful way to explore and understand data. Hand-made data-driven artworks are often presented as a sub-category of data-visualization, yet their aesthetics are often more closely aligned \textit{generative art}-- art shaped through procedural automation. Generative artists frequently work with external data and often emphasize creating abstract, impressionistic compositions as opposed to rigorous visualizations. Unlike direct-manipulation data-visualization tools, platforms for generative art emphasize aesthetic flexibility over visualization accuracy, provide an extreme degree of expressiveness in how artists can map data to visual properties, and support a wide variety of artistic outcomes. Unfortunately, existing generative art platforms restrict many of the key qualities of hand-drawn data art because they hinder manual aesthetics and pose barriers for people accustomed to manual creation. We hypothesize that by developing approachable programming platforms that integrate manual expression and the manipulation of external data, we can enable the creation of expressive generative data-driven artwork with hand-drawn aesthetics. To explore this, we developed Data Brushes, a programming and drawing environment targeted at people with experience in drawing. Data Brushes drawing-oriented interface makes the system approachable to people without prior programming experience, while the system's programming environment enables the system to scale to complex and diverse forms of data art. Data Brushes supports the creation of manual art through three inter-working components: 1) a programming model that aligns external data manipulation and the manipulation of manual drawing data, 2) an internal data visualization and inspection toolkit that aids artists in making informed decisions when mapping external data to aesthetic attributes, and 3) a record and looping mechanism that supports iteration and exploration of data-driven artwork. We demonstrate the expressiveness of our approach through static and temporal data-driven artworks produced with Data Brushes. Results from an iterative evaluation with artists demonstrate the flexibility and learnabilty of our approach. 
\end{abstract}
\category{D.2.6}{Programming Environments}{}
\keywords{\plainkeywords}

\section{Introduction}
% p1 Our defintion of generative art
% p2 Tools for creating generative art- totally programmatic, or constrained DM tools. Maybe introduce DB 
% p3 Follow approach / extend DM paragraph that says that we're building on dynamic brushes but different in these keys ways
%clean separation between data and code- distinguish between dynamic brushes
%data-driven generative art- Dynamic Brushes didn't have a clean distinction between the two.  Bring in data from external sources
%p4 connect to data visualization and performance- prior system handling manual input as data. We've made that stronger.
% Joel's questions about data driven generative art and generative art in general
% visualization community has made a lot of progress in exploratory data visualization- we can build on this progress if we take into account the way that artists think about data visualization
% page 2 is describing the community you are targeting
%sense making process in dataviz community?
%spend time how to define data viz community - where those communities are the same and where they're different.
Computers have changed how we make art. One of the most significant examples of this change is encapsulated by the practice of \textit{computational generative art}. Definitions vary, but broadly speaking, generative art is the practice of describing autonomous computational processes that read information from a predefined environment or context and operate on this input to create perceivable artistic output~\cite{shiffman2012nature,reas2010form,doi:10.1080/14626268.2012.709940}. Generative art is relevant to a broad range of domains including visual art, music, and architecture and offers powerful creative opportunities. These include practical benefits like efficiency and speed, expressive benefits like flexibility and increased capacity for exploration, and structural benefits like scalability and abstraction~\cite{mitchell1990}. Moreover, the autonomous nature of generative art practice offers new ways to think about art creation, by treating the computer as an active creative partner~\cite{reas2010form}. 

Efforts to develop tools for generative artists have primarily focused on low-level ``creative coding'' programming tools~\cite{grasshopper,processing,openframeworks}. Though varied somewhat, these approaches generally use an imperative programming paradigm and an external textual or visual programming representation. Creative coding programming languages are highly expressive, yet they retain the challenges of general purpose languages in that they are often highly complex, yet brittle~\cite{mccullough}, present steep initial learning barriers~\cite{Jacobs:2017:SEP:3025453.3025927}, and frequently exclusively emphasize top-down planning-oriented working styles~\cite{Schachman:2012:API:2384592.2384594}. Research efforts to address the learning challenges of representational creative coding platforms have centered around developing high-level direct-manipulation systems~\cite{Schachman:2012:API:2384592.2384594,Jacobs:2017:SEP:3025453.3025927,Hoarau,kitty}, that enable artists to manipulate programmatic-like relationships through direct selection. Direct-manipulation tools can be easier to get started with than representational programming languages, yet to this point, available systems also place more constraints on expressiveness and flexibility.

In the interest of supporting approachable access to diverse and expressive generative art creation, we argue for an alternative approach of developing new, generative-art specific programming models centered around the expressive and approachable manipulation of different forms of external data. Rather than move away from the expressive opportunities of an external programming representation, we propose building on  the similarities between \textit{data visualization} and generative art. \jingyi{this transition doesn't make a lot of logical sense to me - i still don't see the link between representational programming and dvis?} While different in some respects, data visualization and generative art share a common structure of mapping information to perceivable output. Yet, whereas generative art programming tools focus on simplifying access to basic graphic operations and supporting interactive input, efforts to support data visualization often emphasize providing flexible yet straightforward representations of data and aim to simplify and streamline the process of mapping different forms of data to visual output~\cite{Heer:2010:DLD:1907651.1908001}. \jingyi{i'm not sure i understand the 'yet' transition--these look like similarities to me? i could argue generative art is also mapping different forms of data (mostly user interactions) to visual output} In recognition of the similarities between data visualization and generative art, and the limitations and challenges of existing generative art platforms, we present a new tool for generative art that contains a domain-specific programming model and data representation inspired by approaches in data visualization. 

In this paper, we make the following contributions. \textit{First} we present \textit{Data Brushes}, an integrated  tool for generative art. Data Brushes builds off the infrastructure of Dynamic Brushes, a system for integrating manual and procedural drawing through a combined drawing and visual programming environment. \jingyi{cite?} ~\textit{Second}, we present the Data Brushes programming model, which allows for generative production by mapping multiple forms of external data---live streaming data, pre-recorded relational data, and synthesized data from mathematical functions---to visual output. \jingyi{the next 3 sentences are good to think through but i think goes in too much detail for an intro} Our model is structured around a clean separation of code and data. All forms of external data are represented under a common \textit{signal} data type. Coding in the model is structured around describing declarative mappings between one or more signals and a given visual output. This approach enables artists to integrate and synchronize multiple forms of input to produce diverse outcomes, and makes it easy to gradually build more complex behaviors, explore alternatives, and re-purpose code by changing the input.~\textit{Third}, we support the process of iteration and experimentation in Data Brushes through a mechanism for recording and looping live input to the system. \jingyi{how is this different than contrib 1? this kind of makes it seem like contrib 1 is just dynamic brushes} ~\textit{Fourth} we demonstrate the expressive range of our approach through sample applications and artwork, including manual drawing tools that tools that modulate their appearance over time with respect to prerecorded input data, hand-drawn visualizations of relational datasets, and time-based artwork with generative animation. In detailing the process of creating these samples, we demonstrate how the Data Brushes system enables a performance-based approach to generative art, where work is built up through an iterative process of recording, looping, and procedurally-manipulating live input. \jingyi{i like this performance-based stuff but i feel like it's tacked on suddenly in the end---maybe a paragraph earlier about its advantages and why we were motivated to follow performance art paradigms?}



%In addition to communicating information, visualizations enable people to resolve logical problems~\cite{Card:1997:SIV:857188.857632}. Meaning visualization is a process to think with as well as a process to produce artifacts.

%Our goal is different. Unify the expressive opportunities of manual creation and generative data-driven art through a tool that supports an integration of both data-driven programming and manual drawing. Platform for data exploration AND artifact creation. As is such we emphasize the inclusion of "developer tools" that aid both in understanding the data, understanding the program, and exploring different forms of expression. 


\section{Background}
\subsection{Opportunities and Challenges of Generative Art}
 Definitions for generative art are equally varied, but some consistent factors have emerged. Broadly, generative art describes any form of art which is produced in part or in-whole through an autonomous system or process- one that is structured by, or receives input from a human artist, but also makes decisions independent of the original artist~\cite{Galanter03whatis}. 
 
 Generative art can be produced \textit{without} the use of a computer~\cite{boden}, yet technological approaches to generative art are notable, both for their present popularity~\cite{doi:10.1080/14626268.2012.709940} and their capacity to bring new capabilities to generative art production~\cite{doi:10.1162LEONa00533}.
 
 Despite the expressiveness of  ``creative-coding''  systems offer substantial  expressive variability and flexibility, yet this diversity is often not reflected in current generative art practice.
 
 Unlike other domains, early computer art motivated by the use of media, technique and method, rather than by an ideology, and those participating in them are not traditional artists (mathematicians, engineers, composers)~/cite{reichardt1971computerart}
 
 music is the far most advanced of early computer art~\cite{reichardt1971computerart}
 
 Cathode ray tube display- most advantageous of computer graphics platforms- allows the person drawing to alter the image or the data with no significant lapse of time. He is able to control many parameters in combinations of his own choice and is able to evaluate the relationships of the forms he is manipulating, making use of both intuition and the knowledge of the problem in hand~/cite{reichardt1971computerart}.
 
``The fundamental difference is very simple. With computer art, at least that which is produced by writing a program, the artist must know exactly what is he wants to do and in what areas he is permitting randomness to occur. All this has to be done before the actual image emerges. With action painting, the program is being written as the work on the picture proceeds. This is true to a lessor or greater extend of most pictures, although it is the element of chance in action painting that is always stressed as indeed it is also the one which is emphatically pointed out by those who produce drawings with the aid of computers''~/cite{reichardt1971computerart}.

Role of feedback in Cybernetics

\subsection{comparing data vis and generative art}

Data visualization involves mapping external data to visual forms in ways that enable new insights or understanding of the underlying data. Similarly, generative art involves creating autonomous computational processes that read information from a predefined environment or context, and operate on this input to create artistic output~\cite{schiffman,reas2010form,doi:10.1080/14626268.2012.709940}.

\subsection{Design Goals}

\section{Related Work}
Our research expands upon existing frameworks for generative art: textual programming languages, visual programming languages, and direct manipulation systems. While textual programming languages are expressive, artists face high learning thresholds to fully utilize their expressiveness to produce diverse artworks. %\jen{focus should be on the fact that they have high learning thresholds when it comes to produce diverse outcomes- ie people need to learn a lot to accomplish something custom.} 
Visual programming languages---particularly data flow systems---aim to lower the threshold of textual programming, but often retain the same challenges when working with different types of inputs. Direct manipulation systems abstract away the need to program while enabling generative outcomes, focusing on creating procedural constraints between concrete artwork. % In contrast, Data Brushes allows artists to modify \textit{behaviors} by augmenting a direct manipulation system with an external programming language~\jen{technically our language has elements of both declarative and imperative languages. Focus here should be that we have a visual programming language, paired with a direct manipulation environment, not on the paradigm itself.} through a simplified, universal data model
Data Brushes, in contrast, pairs a direct manipulation environment with an external visual programming language. This language incorporates a robust, generic data representation that lets artists produce generative art through a wide range of different inputs, while also enabling exploration and experimentation.

\subsection{Creative Coding APIs}
Specialized textual programming languages for generative art like Processing~\cite{processing} and Openframeworks~\cite{openframeworks} act as APIs %~\jen{They're not necessarily accessible- rather they are more accessible than just working with straight java or c++. also, in general let's try to avoid using the word "accessible" since it can mean a totally different thing- use easy to get started with, approachable, instead.} 
to existing graphics rendering libraries, with the goal of making programming more approachable compared to their underlying languages like Java or C++. These lower-level languages have high learning thresholds, especially in creating intricate artifacts \cite{Ko:2004:SLB:1032665.1034570}. While these higher-level APIs are powerful and expressive~\cite{processing_handbook,ofbookphil}, they still conform to their underlying languages' abstractions and data structures. Works created often recycle established algorithms, which produce interesting outcomes but are highly complex, and thus operate as ``black boxes,'' obfuscating their internals to artists~\cite{dorin2012framework}. Prominent generative artists like Marius Watz have claimed that because these processes are hard to understand, artists tend to reuse example code with only minor modifications, limiting the creative and aesthetic diversity in generated artifacts~\cite{watz_algorithms,watz-eyeo}. Instead of focusing on simplifying graphics APIs, our system contributes a new data representation agnostic to type centered around transparency, iteration, and flexibility to encourage creative diversity.

\subsection{Visual Programming Systems for Creative Expression}
Visual programming languages address some challenges in textual programming while still maintaining expressiveness; they avoid syntax errors and increase tinkerability ~\cite{myers1990taxonomies,resnick_rosenbaum}~%\jen{be specific about the challenges- namely avoid syntax errors, increase tinkerability/ explorability (cite Resnick Rosenbaum for tinkerability)}. 
A subset of visual programming languages, data flow systems have become popular in recent years among domain experts: Max and Pure Data for music~\cite{max, puredata}, Nodebox for procedural visualization and vector graphics~\cite{nodebox}, Grasshoper for generative architecture~\cite{grasshopper}, and Reactable for tangible live performance~\cite{reactable}. These languages represent programs as directed graphs that filter and operate on data. Data flow systems are well-suited for some tasks like controlling parallel outputs, but are ill-suited for others like iteration because they lack explicit execution control~\cite{Johnston:2004:ADP:1013208.1013209}. In contrast, Data Brushes' external visual programming language is structured as a visual state machine so artists can control transitions between discrete drawing events. %jingyi - could cut last 2 sentences for space since more relevant to dynamic brushes

Some data flow systems, like Max and Grasshopper, employ strict data typing that limits which kinds of nodes can be connected to other ones. Other systems only focus on a single type of data, like music output for Reactable. In contrast, Data Brushes uses a generic, universal data representation that affords arbitrary mappings and connections between all data in the system. We aim to lower the threshold by introducing a higher level of abstraction that simplifies inputs and supports exploration and iteration. This flexibility allows artists to build interactive tools with Data Brushes, rather than solely focus on outcomes and artifacts.



%processing, openframeworks -- their main contribution is an accessible api but they still use the same existing data structures to render graphics, we create our own.

% dataflow languages: nodebox, max, grasshopper, predata -- not well suited for iteration/cyclic events, no execution control. domain specificity. we have a higher level of abstraction, we enable people to create interactive tools which df usually doesn't do

%also, complexity means ppl recycle examples, overuse certain ones -- but the code is a black box, and things they dont understand limits the creative diversity in the generated artifacts, see lots of recycled aesthetics and approaches

\subsection{Dynamic Direct Manipulation Tools}
Although they reduce some programming challenges, visual programming languages require artists to work with program abstractions instead of concrete objects~\cite{victor}. Dynamic direct manipulation systems enable people to describe procedural-like relationships through direct  manipulation. Victor has demonstrated sample dynamic direct manipulation functionality in a wide range of domains, from game development to interactive animation to data visualization ~\cite{inventing_on_principle,victor:dead_fish,victor:dynamic_data_viz}. Because of their visual nature, direct manipulation systems are well-suited to create 2D drawings. Recursive Drawing~\cite{schachman} re-implements a textual programming language as a direct manipulation interface, giving ``alternative programmers'' like artists the power to generate artworks by manipulating visual constraints. Para~\cite{Jacobs:2017:SEP:3025453.3025927} integrates visual constraints with lists and declarative duplication to support procedural art, and Pampliset~\cite{blackwell} uses a layering metaphor to represent image transformations in terms of the image itself. %Even though they lack textual programming representations, all of these systems can retroactively propagate users' local changes across the whole piece. 
Direct manipulation tools have also been built for interactive animations, diagrams, and infographics. Through directly editing animation elements and a relational graph superimposed on the scene, Kitty~\cite{kitty} and Skuid~\cite{skuid} make it easier to create interactive motion graphics. Apparatus~\cite{apparatus} integrates a direct manipulation editor with declarative textual expressions to create interactive diagrams. Recently, researchers have also built direct manipulation tools for data visualization. Data Illustrator~\cite{dataillus} allows users to create infographics and visualizations without textual programming through repeating or partitioning shape primitives which are then lazily bound to data. DataInk~\cite{dataink} uses pen and touch input to bind data to illustrative glyphs, which can be modified in color or composition, to create data drawings. Data-Driven Guides~\cite{kim2017data} generates guides from data mappings helpful in creating infographics, but only offers modifications in length, area and position. While these tools lower the threshold for creating visualizations, their strict input constraints and lack of an external programming representation sacrifice expressiveness---a limitation unsuited for the creative nature of generative art. We augment our direct manipulation environment with an external visual programming language that enables greater freedom in the types of input or data that can be used to make art, as well as greater expressivenss in how this data can be manipulated. %Unlike Para, Data-Driven Guides, or Kitty, our goal is to support interactive \textit{behaviors} to produce generative art, as opposed to manipulating parts of the drawing itself


% generative art - para, recursive drawing, pampliset defines image transformations in terms of the image itself through a layering metaphor and 
% Direct manipulation tools kitty/draco/skuid, apparatus
% bring in external data - ddg, data ink/illustrator

% many systems lack external programming representations. our goal focuses around higher range of expression so we develop an external rep with our direct manipulation environment. unlike para, DDG, kitty, our goal is to enable interactive behaviors to produce drawings, instead of manipulating parts of the drawing itself. 
   


% Visual programming languages reduce some of the challenges of programming, but they still require artists and designers to work through an abstract description rather than a concrete artifact. More recently, Victor demonstrated sample systems with applications in game development, interactive animation, and data visualization~\cite{inventing_on_principle,victor:dead_fish,victor:dynamic_data_viz}. Apparatus~\cite{apparatus} enables the creation of interactive diagrams through an integration of a direct manipulation editor and declarative textual expressions. Pampliset represents parameter values for bitmap transformations as image layers, which can be retroactively adjusted to propagate changes across a composition~\cite{blackwell}. Para supports procedural art through the combination of visually represented constraints, lists, and declarative duplication~\cite{Jacobs:2017:SEP:3025453.3025927}. . We draw inspiration from  

% aparatus, data driven guides (only change scale, position), bret victor, para, data ink, parapheket (?), ruby habeeb (?) -- no external representation, low threshold but also low ceiling. less expressive because they have strict input constraints as opposed to generic inputs that a programming language can would have of how/where data can be used.

% declarative idx - what they do well is recontextualizing the task of data vis to a different audience by putting it in the direct manipulation/declarative language space. we augment this direct manip enviro, our stylus ipad app, with an external programming representation. we apply these principles to generative art. 

\jingyi{do we want to mention anything on polymorphism or the spreadsheet paradigm? palimpsest also employs it}

%TODO add somewhere in paper - heer declarative dvis, interstate

\section{System Description}
~\jen{Let's outline some terminology here.\\
Signal: reference for external data input, represented as a draggable, color-coded block\\
Signal Block: visual representation of a signal
Signal Collection: Collection of related signals that emerge from the same input source\\
Input: Any mechanism that supplies the system with external data \\
Input type: Live (external sensor collecting real time information, Recorded (stored data from live input), Imported (tabular dataset), Synthesized (data generated via mathematical function), Drawing (Self-referential data describing visual properties of generative artwork).\\
Programming Interface: The browser-based interface where artists author procedures and access signals\\
Media Authoring Interface: IOS interface where artists provide live manual input to procedures, preview resultant artwork, and record and export data.\\
Palette: Panel that provides access to available signal types- dragging a signal type from the palette creates a new instance of that signal that can be used in the current procedure.\\
Procedure: A program created in DB that operates on external data (in the form of signals) to produce visual output. Procedures consist of states, transitions, actions, and mappings.\\
Expression: a primitive that accepts single or multiple signals, constants, and textual mathematical expressions as input, and returns a numerical value. Expressions are distributed across the Data Brushes Visual Programming language in mappings, action arguments, and transition events, enabling external data act as input for any of these individual components.
}

Data Brushes is an integrated programming environment and media editor for producing 2D generative artworks. The system centers around the procedural manipulation and mapping of external data to visual outcomes. Data Brushes derives its power and flexibility from a clean separation of two compatible structures: a generic data representation that can store a wide range of different forms of input, and a corresponding visual programming language that enables simple yet expressive mappings of input data to a variety of visual outputs. The Data Brushes interface supports the iterative and experimental process of generative art production through internal mechanisms for manual input, data recording, and iteration. We developed Data Brushes through an iterative process that corresponded with our analysis of prominent approaches in generative art and challenges facing generative artists. We conducted informal interviews with artists who produce generative works and collected a diverse set of prominent generative artworks. Analysis of this data led to a better understanding of the broad categories of generative art our system should enable~\jen{should be more specific here}, as well as specific workflows and practices the system should support---namely exploration, experimentation, and revision. These design targets informed the development of the Data Brushes data representation, programming model, and interface.

\begin{table}
\scriptsize 
 \begin{tabular}{ |p{1.75cm} | p{6.25cm} |}
 \hline
 Live & Real-time performance or interface input \\ \hline
 Recorded & Stored recordings of live input\\ \hline
 Synthetic & Synthesized data generated from mathematical functions\\ \hline
 Imported & External data pulled from tabular datasets\\ \hline
 Drawing &  References to visual properties of generative artwork produced in the system.\\ \hline
 
 \end{tabular}
\caption{Signal Types}
\label{table:signals} 
\vspace{-15pt}
\end{table}
\subsection{Input Representation}
Our analysis of generative art and conversations with generative artists demonstrated the variety of ways in which generative artists work with data. Different artists often relied on different forms of input, incorporated multiple forms of data in their works, and produced variations by mapping different inputs to the same procedure. To accommodate the diverse ways artists work with external data, we centered the development of Data Brushes around a scalable yet approachable set of data primitives. For the purposes of this paper, we define an input as any mechanism that supplies the system with external data. All inputs to Data Brushes are represented under a single generic datatype, the \textit{signal}. In their most basic form, signals are ordered vectors of floating point numbers. The expressiveness of signals results from the manner in which they are ordered and organized with respect to their original input sources and their versatility throughout the Data Brushes programming language. 

Data Brushes contains five signal types that correspond with five categories of input (table~\ref{table:signals}). \textbf{First}, \textit{live signals} provide access to real-time input generated by the artist as a vector of samples. Because most input devices have multiple readable properties (e.g., a multi-axis accelerometer), each property of a live input source is represented as an individual signal. For demonstration purposes, Data Brushes provides access to three categories of live signals derived from real-time stylus, microphone, and user-interface input. Data Brushes' live signal representation is structured to accommodate a future API enabling 3rd parties to register additional live inputs from other sensors and devices. \textbf{Second}, data generated from any live input can be recorded and stored as a \textit{recorded signal}. This enables artists to access data generated from past performances in their programs. \textbf{Third}, \textit{synthetic signals}, produce infinite sequences of values generated by mathematical functions. Artists can choose from a set of predefined generator-type signals (e.g., sine wave, square wave, random generator, etc.) or define a custom function~\jen{interface element for custom function not in place yet..}. \textbf{Fourth}, \textit{imported signals} represent numerical tabular data, enabling artists to access data recorded in an external spreadsheet or JSON file. Imported datasets are converted to a collection of signals, each representing a different column of the original table. At present, Data Brushes provides access to several forms of tabular data drawn from popular quantitative self and personal-tracking applications but our approach is compatible with any form of numerical tabular data. \textbf{Fifth}, the system enables artists to use procedurally-generated artwork itself as input. \textbf{Drawing signals} return data associated with generative drawings produced by the system. We expand on this in detail in the programming process section. 

Signals are stored within \textbf{collections}, which structure signals according to their input source. Collections provide additional organization and structure when referencing signal values, but do not constrain the use of individual within a procedure. Irregardless of their input source, all signals can be used interchangeably and in combination across the Data Brushes programming language. The ordering of each signal is derived from the order in which it was recorded. Signals produced from live input, including recorded signals, are ordered according to time, whereas signals produced from an imported tabular dataset are ordered according to their original row order. Because not all input in Data Brushes is time-based, individual signals lack internal timestamps. To enable time-specific access to temporal signals, all live or recorded collections include a corresponding time signal that can be referenced when accessing values from other sibling signals within a collection. We describe the process of accessing signals in detail in the following section.

\subsection{Programming Language}
Allowing artists to take advantage of the variety of input signals in Data Brushes required that that we revise and extend programming paradigm of Dynamic Brushes to support versatile use of data throughout a procedure. The Data Brushes programming language allows artists to create procedures that use input signals to produce generative compositions. Like behaviors in Dynamic Brushes, procedures in Data Brushes are centered around declarative \textit{mappings} that map external data to visual outputs. Sets of mappings are organized within individual \textit{states}; each set holds true when their enclosing state is active. States are activated through conditional transitions. Transitions can include \textit{actions}-- discrete methods executed when the transition occurs 
All formal parameters of the Data Brushes language are standardized as \textit{expressions}--primitives that that accept single or multiple signals, constants, and textual mathematical expressions as input, and return a corresponding numerical value.  Expressions are distributed across the Data Brushes Visual Programming language in mappings, action arguments, and transition events, enabling external data to act as input for any of these individual components.~\jingyi{i think the comparison to dynamic brushes might be a bit too explicit in the framing here?}

Data Brushes' emphasis on data also necessitated the development of expressive controls for accessing and filtering data. Rather than act as scalar inputs, Data Brushes' signals store a persistent sequence of values. By default, signals return a value associated with their internal index. However, Data Brushes also contains an internal querying protocol that enables signal values to be referenced by a specific index or with respect to values of other signals in the same collection. The querying protocol also provides mechanisms for sorting or filtering any one signal to return a subset or specific ordering of values. In the interface and applications sections, we describe in detail how artists specify queries in the Data Brushes interface. 

\subsection{Interface}
The Data Brushes interface consists of a programming environment and a media authoring environment. The programming environment is a JavaScript application running in a web browser and the media authoring one is an iOS application running on an iPad Pro. A Node.js server mediates communication between the two.

The programming environment enables artists to create procedures and provides access to input signals. The programming environment reflects Data Brushes' underlying separation of data and code by dividing the interface between sections for authoring procedures and accessing input data. The \textit{scripting area} is where artists compose procedures. Akin to the process of adding nodes in visual dataflow languages, new states are added through a double-click on the scripting background and transitions are initialized by dragging connectors between states.  Mappings can be added to states by selecting a \textbf{+} icon in the state that pulls up a menu of possible mapping properties to select from. Actions can be added in the same manner through an icon located in each transition. 

The programming interface's sidebar organizes and provides access to input data. The sidebar contains a palette that lists available signals, organized by input type and collection. Every signal is represented as a block that is color-coded to correspond with its input type and collection. Because they are represented as blocks, signals are composable and tinkerable; they can be dragged and dropped onto any box in the scripting area that accepts expressions---whether a mapping, an action, or a transition.  Artists can also copy the contents of any expression and paste it to other contexts: for example, the content of a mapping expression can be used as input to an an action argument. Once artists add a signal block to a procedure, they can hover over the block to inspect the signal's values as they change. Just as signals from different input sources share a generic datatype, signal blocks can be used interchangeably and in combination throughout the visual programming language. This structure greatly increases the expressiveness of Data Brushes by allowing external data to determine visual properties of an artwork, drive transitions within an procedure, and define drawing origins.

The media authoring interface enables artists to provide live input to procedures, preview resultant artwork, and record and export data. Live input includes gestures from the stylus, data from the microphone, and selections from the UI controls like setting the stroke color or opacity. Although Data Brushes privileges manual stroke-based drawing to better match existing art practices, artists can choose not to incorporate stylus input depending on their generative art procedures. Artists also have the ability to record and export live input data with the media authoring interface's recording timeline. A new frame is created in the recording timeline each time the artist makes a gesture on the canvas. Artists can then select a sequence of these frames to export as input data. This input data shows up as signal blocks in the programming environment palette and can also be used interchangeably in any expression area. Because authoring procedures in generative art generally involve heavy revision and experimentation, artists can also loop their frame sequences in the recording timeline. During this looping, the artwork on the canvas automatically reflects changes made to its procedures in the programming environment; these quick output previews allow artists to explore and iterate on their generative art.

~\jen{need to add section on filtering signals in interface}
\section{Applications}
\subsection{Programming Process}
\subsection{Generative Drawing Tools}
\subsection{Data Visualization}
\subsection{Time-driven behaviors}

\balance{}

% BALANCE COLUMNS
\balance{}

% REFERENCES FORMAT
% References must be the same font size as other body text.
\bibliographystyle{SIGCHI-Reference-Format}
\bibliography{references}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
